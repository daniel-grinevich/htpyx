<div class="w-full border-b border-black marquee-default">
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin</span>
    <span class="font-vt text-sm inline-block mr-4">Margin test</span>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="border border-black p-4 relative">
        <h1 class="font-roboto text-3xl md:text-4xl lg:text-5xl sm:text-lg">{name}</h1>
        <h6 class="font-roboto text-xl mt-4 mb-2">Project Description</h6>
        <p class="font-nunito text-md">{description}</p>
        <div class="absolute bg-custom-red px-1 border border-black" style="top: -15px; left: -30px; text-md">
            Header 1
        </div>
    </div>
    <div class="font-roboto bg-custom-red block border border-black p-4 mt-4 text-center">
        Important Information Goes Here
    </div>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 py-4">
        <div>
            <h6 class="font-roboto text-xl mt-4 mb-2 border-b border-black">Project Goal</h6>
            <p class="font-nunito text-md">{goal}</p>
        </div>
        <div>
            <h6 class="font-roboto text-xl mt-4 mb-2 border-b border-black">Technologies Used</h6>
            <p class="font-nunito text-md">{stack}</p>
        </div>
    </div>
    <div class="flex flex-col items-center justify-center py-8">   
        <a id="githubLink" href="{github}" class="border border-black text-black px-4 py-2 inline-block hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-black active:bg-gray-300" style="margin-top: -2px; text-align: center;">
            <span class="font-nunito text-md">View source code</span> <!-- Consistent font usage -->
        </a>
    </div>
</div>
<div class="w-full border-t border-b border-black p-4 relative flex justify-center bg-custom-pink">
    <h1 class="font-vt text-3xl md:text-4xl lg:text-5xl sm:text-lg">Keep Scrolling</h1>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="p-4 relative">
        <h6 class="font-roboto text-xl mt-4 mb-2">High Level Architecture</h6>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 left-0">
            Subheader 1
        </div>
    </div>
    <div class="w-full relative justify-center sm:hidden md:flex">
        <canvas id="myArchitecture"  width="500" height="500" style="border: 1px solid black;">
        </canvas>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 right-0">
            Drag & Drop!
        </div>
    </div>
    <div class="p-4  my-4 relative">
        <p class="font-nunito text-md">
            The architecture of HTpyX is inspired by Django, making it easier for developers to transition between 
            the two frameworks. HTpyX serves as a lightweight framework ideal for quickly crafting prototypes or proofs 
            of concept, while Django can be employed to develop robust, production-ready applications. Through class inheritance, 
            HTpyX enables the creation of reusable views that can be extended with versatile components. These components are designed 
            to respond efficiently to HTMX requests, making the framework as responsive and fluid as coding a single-page application
             with React. 
            
        </p> 
    </div>
    <div class="p-4 relative">
        <h6 class="font-roboto text-xl mt-4 mb-2">Building the View Layer</h6>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 left-0">
            Subheader 2
        </div>
        <p class="font-nunito text-md py-2">
            One of the foundational elements of any web framework is the view layer, which defines the endpoints that your application responds 
            to. In HTpyX, this critical layer is implemented by extending the BaseView class. Let’s dive into the core methods of the BaseView 
            class to see how they shape the functionality and responsiveness of your application.
        </p>
    </div>
</div>
<div class="max-w-4xl mx-4 lg:mx-auto grid grid-cols-1 lg:grid-cols-[1fr_2fr] border border-black">
    <!-- Left Column -->
    <div class="grid grid-cols-2 lg:grid-cols-1 lg:auto-rows-fr">
        <div id="dispatch" data-value="selected" class="flex justify-center items-center relative p-2 border-r border-b border-black">
            <div class="absolute bg-custom-red h-full w-full left-0 top-0"></div>
            <span class="z-10 relative">Dispatch</span>
        </div>
        <div id="get" data-value="not-selected" class="flex justify-center items-center relative p-2 lg:border-r border-b border-black">
            <div class="absolute bg-custom-red h-full w-1 left-0 top-0"></div>
            <span class="z-10 relative">Get</span>
        </div>
        <div id="render" data-value="not-selected" class="flex justify-center items-center relative p-2 border-r border-b border-black">
            <div class="absolute bg-custom-red h-full w-1 left-0 top-0"></div>
            <span class="z-10 relative">Render</span>
        </div>
        <div id="reactive" data-value="not-selected" class="flex justify-center items-center relative p-2 lg:border-r border-b lg:border-b-0 border-black">
            <div class="absolute bg-custom-red h-full w-1 left-0 top-0"></div>
            <span class="z-10 relative">Reactive</span>
        </div>
    </div>
    <div class="flex justify-center items-center p-4">
        <div class="flex flex-col justify-center p-4">
            <div class="flex flex-col rounded-xl h-80 text-white bg-black">
                <div class="flex h-10 rounded-t-xl bg-gray-700 flex-row px-2 items-center justify-between">
                    <svg width="60" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="10" cy="10" r="5" fill="#EA3737"></circle>
                        <circle cx="30" cy="10" r="5" fill="#FFB200"></circle>
                        <circle cx="50" cy="10" r="5" fill="#00BE43"></circle>
                    </svg>
                    <div>
                        <h6 class="font-roboto text-sm">Project/HTpyX/BaseView</h6>
                    </div>
                </div>
                <div class="p-1 flex flex-col justify-start overflow-scroll bg-black rounded-b-xl">
                    <code id="terminal" class="font-mono text-sm text-white p-1">
                        <div><span class="purple-code">def</span> <span class="blue-code">dispatch</span>(<span class="red-code">self</span>, request):</div>
                        <div style="padding-left: 20px;">htmx = <span class="blue-code">getattr</span>(request, <span class="green-code">"HTTP_HX_REQUEST"</span>, None)</div>
                        <div style="padding-left: 20px;">method = <span class="blue-code">getattr</span>(request, <span class="green-code">"REQUEST_METHOD"</span>, None)</div>
                        <div style="padding-left: 20px;"><span class="purple-code">if</span> <span class="blue-code">hasattr</span>(<span class="red-code">self</span>, method.lower()):</div>
                        <div style="padding-left: 40px;"><span class="purple-code">if</span> htmx:</div>
                        <div style="padding-left: 60px;">handler = <span class="blue-code">getattr</span>(<span class="red-code">self</span>, <span class="orange-code">"reactive"</span>)</div>
                        <div style="padding-left: 60px;">component = <span class="blue-code">getattr</span>(request, <span class="green-code">"HTTP_X_COMPONENT"</span>)</div>
                        <div style="padding-left: 60px;"><span class="purple-code">return</span> handler(request, component)</div>
                        <div style="padding-left: 40px;"><span class="purple-code">else</span>:</div>
                        <div style="padding-left: 60px;">handler = <span class="blue-code">getattr</span>(<span class="red-code">self</span>, method.lower())</div>
                        <div style="padding-left: 60px;"><span class="purple-code">return</span> handler()</div>
                        <div style="padding-left: 20px;"><span class="purple-code">elif</span> <span class="blue-code">hasattr</span>(super(), method.lower()):</div>
                        <div style="padding-left: 40px;">handler = <span class="blue-code">getattr</span>(super(), method.lower())</div>
                        <div style="padding-left: 40px;"><span class="purple-code">return</span> handler()</div>
                        <div style="padding-left: 20px;"><span class="purple-code">else</span>:</div>
                        <div style="padding-left: 40px;"><span class="purple-code">return</span> <span class="red-code">self</span>.<span class="orange-code">http_method_not_allowed</span>()</div>
                    </code>
                </div>
            </div>
        </div>
    </div>
    <div class="relative col-span-1 lg:col-span-2 bg-gray-200 border-t border-black p-4">
        <p id="code-description" class="font-nunito text-md">
            The dispatch method is called when the view is accessed by the router. It looks 
            for the method that matches the request method on the child view class. If there 
            is no method then it will call the method on the parent (base) view class.
        </p>
    </div>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="p-4  my-4 relative">
        <p class="font-nunito text-md">
            These are the core methods that power the view layer in HTpyX. By simply extending the BaseView class and providing an HTML 
            template, you can create a fully functional view, complete with routing and HTMX support—how convenient is that? Each custom 
            view now essentially functions as its own BaseView. This setup allows you to define templates or data that become accessible 
            across all components, streamlining the development process and enhancing component interaction. Now let's take a look at the 
            code that is running this website! 
        </p> 
    </div>
    <div class="p-4 my-4 bg-custom-pink shadow rounded-lg relative border border-black overflow-auto">
        <pre class="text-sm text-black font-mono">
            class HomeView(BaseView):
                def __init__(self, request):
                    super().__init__()
                    self.request = request
                    # Declare your components
                    self.components = {
                        "nav": NavComponent(name="nav_component"),
                        "sidebar": SidebarComponent(name="sidebar_component"),
                    }

                # Overwrite any context data
                def get_context_data(self):
                    data = {"title": "Daniel Grinevich"}
                    return data

                # Define a template
                def template(self):
                    template_path = "homepage/index.html"
                    return template_path
        </pre>
    </div>
    <div class="p-4  my-4 relative">
        <p class="font-nunito text-md">
            With just a few lines of code, you can achieve a fully functional view layer. You can override any of the base methods to 
            enhance the context passed to the view. In the example shown, I override the get_context_data method to pass in a dictionary 
            of data, which overrides the default context data. Most importantly, I define a list of components that are passed into the 
            template and rendered, creating reactive and reusable components. As you can see, the sidebar to the right of this screen is one of 
            the components that was created. 
        </p> 
    </div>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="p-4 relative">
        <h6 class="font-roboto text-xl mt-4 mb-2">The Reactive Component System</h6>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 left-0">
            Subheader 3
        </div>
        <p class="font-nunito text-md py-2">
            Now that we've covered how to create custom views with components, let's explore how they interact with HTMX requests. We'll 
            examine two examples. The first is a sidebar component that responds to an HTMX GET request for project 
            data. The second is a contact form component that handles a HTMX POST request, saving data to the NoSQL database.
        </p>
    </div>
    <div class="flex flex-col justify-center items-center relative">
        <p>GET request</p>
    </div>
    <div class="p-4 my-4 bg-custom-pink shadow rounded-lg relative border border-black overflow-auto">
        <pre class="text-sm text-black font-mono">
        def reactive(self, request):
            # We are going to have to specify if its a GET or POST we want to handle
            if request.REQUEST_METHOD == "GET":

                data = getattr(request, "htmx-data", None)

                if data:
                    project_name = data.get("project")
                    project = Project()
                    project_obj = project.find_one(lambda x: x["slug"] == project_name)

                if project_name == "htpyx":
                    template_path = "partials/htpyx_project.html"
                elif project_name == "navi":
                    template_path = "partials/navi_project.html"
                else:
                    template_path = None

                return self.render(template=template_path, data=project_obj)
        </pre>
    </div>
    <div class="flex flex-col justify-center items-center relative">
        <p>POST request</p>
    </div>
    <div class="p-4 my-4 bg-custom-pink shadow rounded-lg relative border border-black overflow-auto">
        <pre class="text-sm text-black font-mono">
        def reactive(self, request):
            if request.REQUEST_METHOD == "POST":
                try:
                    data = getattr(request, "htmx-data")
                    name = data["name"][0]
                    email = data["email"][0]
                    phone = data["phone"][0]

                    contact = Contact()
                    contact.add({"name": name, "email": email, "phone": phone})

                    template_path = "partials/success.html"
                    return self.render(template=template_path)
                except Exception as e:
                    print(f"Error: {e}")
                    template_path = "partials/error.html"
                    return self.render(template=template_path)
        </pre>
    </div>
    <p class="font-nunito text-md py-2">
        So far, this process should look fairly standard. We are determining whether the request method is GET or POST and 
        then processing the data passed to perform specific actions. As you might recall from the dispatch method code, 
        we check for an HTTP_HX_REQUEST attribute to identify an HTMX request. If this attribute is present, it indicates that one of our 
        components is reacting to a user event, and we can map the response accordingly. However, you might be curious about the HTMX-DATA attribute mentioned 
        in the example. This is a special attribute created by our custom middleware, designed specifically to handle data passed in by HTMX requests. For instance, 
        in the POST scenario, all attributes submitted through the form are captured within the HTMX-DATA attribute.
    </p>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="p-4 relative">
        <h6 class="font-roboto text-xl mt-4 mb-2">The ORM</h6>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 left-0">
            Subheader 4
        </div>
        <p class="font-nunito text-md py-2">
            The ORM in HTpyX is designed to interact in a NoSQL-like manner. Considering this is the first version of the framework and it is primarily 
            intended for prototyping projects, I have chosen to store all data in a folder, with each model represented by its own JSON file. This approach provides a cost-effective way to store, 
            manipulate, and retrieve data, making it ideal for prototyping 
            and development phases. Currently, the functionality includes simple CRUD operations for the models and the ability to create custom queries.
        </p>
    </div>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="p-4 relative">
        <h6 class="font-roboto text-xl mt-4 mb-2">Template Rending with the Custom Engine</h6>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 left-0">
            Subheader 5
        </div>
        <p class="font-nunito text-md py-2">
            The template engine is another extensively built feature of HTpyX. 
            Like Django’s, it’s designed to be lightweight and straightforward, 
            allowing you to easily add content to your views. One of its standout qualities 
            is flexibility; it doesn’t require strict structural constraints for data storage. 
            This makes it exceptionally user-friendly, supporting rapid development by simplifying 
            the way you integrate and manage data.
        </p>
        <div class="p-4 relative flex flex-col justify-start gap-4">
            <h6 class="font-roboto text-md border-b border-black w-fit">Template Inheritance</h6>
        </div>
        <p class="font-nunito text-md px-4 py-2">
            Template inheritance in HTpyX follows the standard set by many other frameworks. It enables developers to define a 
            base template with common layout elements and override specific sections with content. The 
            PROCESS_TEMPLATE_INHERITENCE function parses the base template to identify placeholders or block tags, 
            which are then dynamically filled with content defined in view templates. This hierarchical structure ensures that the 
            application maintains a consistent look and feel while allowing each page or component to present unique content and 
            functionality, thereby improving maintainability and scalability of the codebase.
        </p>
        <div class="p-4 relative flex flex-col justify-start gap-4">
            <h6 class="font-roboto text-md border-b border-black w-fit">Component Integration</h6>
        </div>
        <p class="font-nunito text-md px-4 py-2">
            Component integration within HTpyX enhances modularity and reusability by allowing developers to define standalone, 
            reusable components that can be embedded within various parts of the application. Through the PROCESS_COMPONENT_INJECTION 
            function, the Template Engine dynamically inserts these components into the view template during rendering. Each component 
            can include its own logic and rendering rules, which are processed separately before being integrated into the page. 
            This system promotes a clean seperation of concerns and enables easier updates and testing, as components can be 
            developed and maintained independently from the main application code.
        </p>
        <div class="p-4 relative flex flex-col justify-start gap-4">
            <h6 class="font-roboto text-md border-b border-black w-fit">Error Handling</h6>
        </div>
        <p class="font-nunito text-md px-4 py-2">
            The engine implements comprehensive error checks during the template rendering process, such as verifying the 
            existence of template files before attempting to load them. If an error occurs, such as a missing template or a missing data key, 
            the engine gracefully handles these exceptions by returning user-friendly error messages or placeholder comments in the generated HTML.
        </p>
    </div>
</div>
<div class="max-w-3xl mx-auto py-8 px-4 lg:px-0">
    <div class="p-4 relative">
        <h6 class="font-roboto text-xl mt-4 mb-2">Future of HtpyX</h6>
        <div class="absolute bg-custom-red px-1 text-md border border-black top-0 left-0">
            Subheader 6
        </div>
        <p class="font-nunito text-md py-2">
            For now, HTpyX will remain a prototyping tool for my personal projects. If I decide to move forward with the development of this framework, I plan to incorporate features more similar to those found in Next.js. 
            Specifically, I would shift the routing to be based on the file structure, where everything related to a particular view is defined in one file. This approach would foster a more 
            organized and modular development environment. Despite these changes, I would maintain a Django-style approach for developing views and components. I believe there is a market niche 
            for a hybrid framework that effectively combines the strengths of Python with the dynamic capabilities of React.
        </p>
    </div>
</div>
<div class="w-full border-t border-b border-black p-4 relative flex justify-center bg-custom-pink">
    <h1 class="font-vt text-3xl md:text-4xl lg:text-5xl sm:text-lg">Thanks for reading!</h1>
</div>